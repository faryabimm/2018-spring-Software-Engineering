%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%                   PROBLEM 1                   %%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{پرسش اول}
با مطالعه در مورد متودولوژی 
\lr{Twelve-factor app}
به پرسش‌های مطرح شده پاسخ می‌گوییم:

\subsection{بررسی انطباق هر یک از فاکتور‌های دوازده گانه با فاکتور‌های کیفی ‌McCall}
\subsubsection{\lr{Codebase}}
یک برنامه‌ی 
twelve-factor
باید دارای یک codebase واحد باشد اما می‌توان گسترش‌های متفاوتی را از همین codebase واحد برای آن متصور بود. به عنوان مثال یک گسترش برای آزمون نرم‌افزار در محیط سرور آزمون، یک گسترش به ازای هر توسعه‌دهنده در محیط داخلی سیستم توسعه‌ی او و یک گسترش نهایی  محصول.

این فاکتور بر ویژگی‌های  ناظر بر نگهداری و تغییر نرم‌افزار در مجموعه‌ی McCall نظارت دارد. به این صورت که داشتن گسترش‌های متفاوت برای یک codebase می‌تواند باعث سادگی ایجاد تغییرات در نرم‌افزاری شود که هم اکنون در حال خدمت رسانی و سرویس دهی است (flexibility). به این صورت تغییرات اعمال شده پس از طی چندین گسترش مختلف تست می‌شوند و در نهایت به گسترش نهایی محصول راه می‌یابند.

این فاکتور ناظر بر ویژگی testablility نیز هست. به این صورت که ویژگی جدید یا تغییرات اعمال شده را می‌توان بدون واهمه از مشکل در گسترش محصول در گسترش‌های آزمون به راحتی تست کرد.

همچنین maintainability یک محصول بالاتر خواهد رفت. زیرا کنکاش و اعمال تغییرات برای یافتن مشکلات در codebase در ابتدا در گسترش نهایی انجام نمی‌شود و ریسک ایجاد مشکل برای محصول حین خدمت رسانی وجود ندارد



\imagecsref{1}{0.6}{codebase-deploys}{چندین گسترش با یک codebase}{https://12factor.net/codebase}

\subsubsection{\lr{Dependencies}}
تمام وابستگی‌های یک برنامه باید صراحتا مشخص و ایزوله شوند.
یک برنامه‌ی
twelve-factor
نباید به هیچ عنوان به کتابخانه‌ها و ابزار‌های خارجی موجود در محیط اجرایی میزبان وابسته یا امیدوار باشد. بلکه باید نیازمندی‌ها و وابستگی‌های خود به این ابزار‌ها (مانند کتابخانه‌های زبان که معمولا با ابزار‌های  \lr{package management} نصب می‌شوند یا برنامه‌های کاربردی shell) را صراحتا اعلام کند و در محیطی ایزوله از محیط بیرونی خود در سیستم این  نیازمندی‌ها را برای خود فراهم کند (مثل استفاده از virtualenv در زبان پایتون).

این فاکتور ناظر به برخی از ویژگی‌های کیفی McCallاست.

با بهره‌گیری از این فاکتور برنامه usability بیشتری خواهد داشت.
توسعه‌دهندگان جدید و کاربران وقت بسیار کمتری را صرف آماده کردن محیط خارجی کد در سیستمشان و نصب نسخه‌ی مناسب کتابخانه‌ها و ابزار‌های مورد  نیاز کد و رفع تداخلات خواهند کرد.

این فاکتور باعث portability بیشتر کد و برنامه برای اجرا در محیط‌های متفاوت خواهد شد. به این صورت که تفاوت‌های معماری و ساختاری محیط‌های متفاوت تاثیر کمتری بر کد خواهد داشت. زیرا کد برای رفع نیازمندی‌های خود به آنچه در سیستم هدف وجود دارد وابسته نیست.

این فاکتور حتی باعث افزایش interoperabality هم خواهد شد. زیرا چندین برنامه می‌توانند در یک سیستم واحد در کنار هم کار کنند و هیچیک از یک مجموعه‌ی مشترک برای رفع نیازمندی‌های خود استفاده نکنند. به این صورت جلوی تداخلات احتمالی نیازمندی‌هایشان و کتابخانه‌ها گرفته خواهد شد.


\subsubsection{\lr{Config}}
این فاکتور بیان می‌کند که تنظیمات و config مربوط به گسترش بایستی در متغیر‌های محیطی 
\lr{environment varaibles}
ذخیره شود. این تنظیمات شامل دسترسی‌ها به سرویس‌هایی مانند پایگاه داده و صف‌ها، اطلاعات محرمانه مانند token های امنیتی دسترسی به سرویس‌های خارجی و تنظیمات مربوط به گسترش خاص هستند.

این اطلاعات نباید به صورت 
فایل‌ config در repository ذخیره شوند زیرا codebase نباید شامل اطلاعاتی باشد که در گسترش‌های متفاوت فرق خواهد کرد. همچنین نباید این اطلاعات درون فایل‌هایی با اسامی مختلف ذخیره شود و در زمان گسترش بین انتخاب از آنها تصمیم گرفته شود زیرا با بزرگ شدن پروژه مدیریت این فایل‌ها نیز دشوار خواهد شد.

این فاکتور ناظر بر چندین ویژگی McCall است.

استفاده از آن باعث افزایش 
integrity
خواهد شد. به این ترتیب می‌توان با تنظیم متغیر‌های محیطی مختلف در محیط‌های گسترش مختلف دسترسی‌های مختلفی را تنظیم کرد.

باعث افزایش portability خواهد شد زیرا codebase حاوی اطلاعات گسترش نیست و می‌تواند به سادگی و بدون تغییرات در گسترشی دیگر مورد استفاده قرار بگیرد.

راه را برای ارائه‌ی flexibility بیشتر هموار می‌کند. با استفاده‌ی درست از متغیر‌های محیطی می‌توان به سادگی و سرعت رفتار یک سیستم در حال خدمت را  تغییر داد.


\subsubsection{\lr{Backing Services}}
این فاکتور بیان می‌کند یک نرم‌افزار 
twelve-factor
بایستی با سرویس‌های backing مانند پایگا‌ه‌های داده، ابزار‌های مدیریت صف، ابزار‌های مدیریت حافظه، ابزار‌های تبادل و مدیریت ایمیل و سایر ابزار‌های کمکی داخلی و یا خارجی مانند منابع متصل به سیستم برخورد کند. به این صورت که شناسه و handle این ابزار‌ها در یک پیکربندی ذخیره شده و برنامه از طریق این پیکربندی بتواند به منبع مورد نظر دسترسی داشته باشد. این اطلاعات و تنظیمات نباید در کد برنامه ذخیره شوند.

نباید از دید برنامه تفاوتی میان یک پایگاه داده‌ی داخلی و یک پایگاه داده‌ی راه دور تهیه شده از شرکتی مثل amazon وجود داشته باشد. بایستی در هرلحظه امکان تغییر استفاده از یک منبع به منبع دیگر با تغییر دادن handle آن منبع در پیکربندی موجود باشد.

به این صورت coupling بین مولفه‌های نرم‌افزار به شدت پایین می‌آید.

استفاده از این فاکتور ناظر بر چندین ویژگی McCall است.

با coupling بسیار کم بین مولفه‌های یک سیستم امکان تغییر در یک سیستم در حال اجرا (flexibility) مهیا می‌شود. امکان نگهداری سیستم بالاتر می‌رود زیرا می‌توان به سادگی مولفه‌های دارای ایراد را با مولفه‌های سالم جایگزین کرد (maintainability). می‌توان به سادگی مولفه‌های آزمون را بری آزمون سیستم به آن متصل و از آن جدا کرد (testability). می‌توان به سادگی از یک مولفه در سیستمی دیگر استفاده کرد(reusablility). می‌توان چندین مولفه را به سادگی و در تعامل با یکدیگر در یک سیستم مورد استفاده قرار داد (interoperability). می‌توان بدون تغییر از codebase در محیط‌های متفاوت و با منابع متصل متفاوت استفاده کرد (portability).

\imagecsref{2}{0.85}{attached-resources}{تعامل با سرویس‌های backing مانند منابع متصل به سیستم}{https://12factor.net/backing-services}


\subsubsection{\lr{Build, release, run}}
این فاکتور بیان می‌کند که در یک نرم‌افزار 
twelve-factor
گام‌های build و release و run بایستی جدا از هم دیده شوند.

در گام build
،
codebase
برنامه در commit مورد نظر توسعه‌دهنده از repository دریافت شده، و با ادغام با کتابخانه‌های مورد استفاده build شده و تبدیل به فایل‌های binary قابل اجرا می‌شود.

در گام release تنظیمات اجرایی محیط به نتیجه‌ی گام قبل اضافه شده و بسته‌ای اجرایی تولید می‌شود که شامل فایل‌های باینری اجرایی و تنظیمات گسترش است.

در نهایت گام run گامی است که بسته‌ی اجرایی نهایی را در محیط گسترش اجرا می‌کند.

گام run بایستی حتی‌الامکان گامی کوچک و متشکل از چند قدم ساده باشد. زیرا این گام ممکن است هر لحظه به صورت خودکار رخ دهد (راه اندازی مجدد سرور گسترش پس از یک خطا در نیمه‌ی شب را در نظر بگیرید). از این رو این گام نباید پیچیده و خطاخیز باشد چون ممکن است توسعه‌دهنده‌ای برای رسیدگی به این خطا در دسترس نباشد.

هر release هم بایستی برچسبی منحصر به فرد متناسب با آن release دریافت کند که در صورت لزوم بتوانیم به سادگی بین release های مختلف جابه‌جا شویم.

استفاده از این فاکتور ناظر بر چندین ویژگی McCall است.

استفاده از آن باعث افزایش maintainability خواهد شد زیرا در صورت بروز خطا می‌توان به سادگی به یک حالت امن قبل بازگشت.

باعث افزایش reliability خواهد شد زیرا در صورت بروز خطا سیستم می‌توان به recovery خودکار به حالتی امن بپردازد و down-time ای را تجربه نکند.



\imagecsref{3}{0.75}{release}{جدا نگه‌داشتن فاز‌های build و release و run}{https://12factor.net/build-release-run}


\subsubsection{\lr{Processes}}
این فاکتور بیان می‌کند که یک برنامه‌ی 
twelve-factor
بایستی در قالب یک یا چند پردازه‌ی بدون حالت
(stateless)
اجرا شود. حافظه‌ی پردازه یا فایل‌سیستم به هیچ عنوان نباید به عنوان محل ذخیره‌سازی دائمی اطلاعات مورد استفاده قرار گیرند.

در محیطی که تعداد زیادی پردازه‌ی مشابه به سرویس‌دهی مشغول هستند ذخیره‌ی اطلاعات در حافظه‌ی یک پردازه کار درستی نیست چون درخواست‌های بعدی به آن اطلاع ممکن است به پردازه‌ی دیگری ارسال شوند.

همچنین در محیط‌های تک پردازه‌ای هم ممکن است طی اتفاقاتی اطلاعات حافظه‌ی پردازه پاک شود یا در دسترس نباشد.

هر آنچه که باید به صورت پایدار ذخیره شود بایستی در یک پایگاه داده قرار بگیرد.

از دیدگاه ویژگی‌های McCallاستفاده از این فاکتور باعث افزایش reliability می‌شود زیرا احتمال در دسترس نبودن اطلاعات در یک دسترسی در محیط‌های parallel یا از دست رفتن آنها به دلیل اتفاقی غیر منتظره بسیار کم می‌شود.

\subsubsection{\lr{Port binding}}
این فاکتور بیان می‌کند که یک برنامه‌ی 
twelve-factor
به صورتی کاملا  مستقل فعالیت می‌کند و نیازی به ورود یک webserver در زمان اجرا برای ارائه‌ی خدمت خود ندارد.

به این صورت که چنین برنامه‌ای با reveal کردن یکی از port های سیستم یا container میزبان به بیرون و گوش دادن روی آن پورت برای درخواست‌های ورودی به ارائه‌ی خدمت می‌پردازد.

به این صورت یک برنامه می‌تواند به عنوان یک 
\lr{backing service}
برای یک برنامه‌ی دیگر مورد استفاده قرار بگیرد و برنامه‌ی استفاده کننده با در اختیار داشتن URI آن برنامه از آن سرویس بگیرد.


از دیدگاه ویژگی‌های McCallاستفاده از این فاکتور باعث افزایش interoperability می‌شود زیرا چند سیستم می‌توانند به عنوان سرویس دهنده و سرویس گیرنده در کنار یکدیگر به غعالیت بپردازند.

باعث افزایش reusability خواهد شد زیرا می‌توان از این برنامه‌ی self-contained در جاهای دیگر استفاده کرد.

باعث افزایش portability می‌شود زیرا یک برنامه‌ی self-contained وابستگی کمی به محیط اجرا دارد و می‌توان آن را به سادگی به محیط‌های دیگری منتقل کرد.

\subsubsection{\lr{Concurrency}}

در یک برنامه‌ی 
twelve-factor
از انواع مختلف پردازه‌ها برای رسیدگی به کار‌های مختلف استفاده می‌شود. بسته به میزان workload هر کار ممکن است تعداد کم یا زیادی از پردازه‌ی رسیدگی‌کننده به آن کار تولید شود.

مدل پردازه‌ای برای افزایش ابعاد محصول بسیار مفید و پرکاربرد است. کافی است تعداد پردازه‌های رسیدگی کننده به کار متناسب با افزایش حجم آن کار افزایش یابد.

در  یک برنامه‌ی
twelve-factor
هیچگاه از پردازه‌های daemon استفاده نمی‌شود و مدیریت پردازه‌ها هم به صورت خودکار توسط سیستم عامل صورت می‌پذیرد.


از دیدگاه ویژگی‌های McCallاستفاده از این فاکتور باعث افزایش efficiency و reliablility می‌شود. زیرا با شکستن کار و موازی کردن آن نیاز به منابع مورد نیاز (من جمله زمان) نسبت به حالت تک عاملی کمتر می‌شود و همینطور با افزایش فشار کاری بر سیستم احتمال شکست سیستم و خطا در آن به صورت چشمگیر افزایش نمی‌یابد.

\imagecsref{4}{0.6}{process-types}{بالابردن ابعاد با استفاده از مدل پردازه‌ای}{https://12factor.net/concurrency}


\subsubsection{\lr{Disposability}}

در یک برنامه‌ی twelve-factor پردازه‌ها بایستی به سرعت از لحظه‌ی دستور شروع به کار به حال آماده به کار در آیند. در چنین سناریو‌یی مدیر پردازه می‌تواند بسته به میزان فشار کاری، به سرعت نسبت به افزایش منابع اقدام کند (کمینه کردن زمان startup هر پردازه).

همچنین باید پردازه‌ها به صورت graceful از بین بروند به این صورت که پردازه با دریافت سیگنال
SIGTERM ابتدا وظیفه‌ی محول شده را انجام داده یا عدم امکان انجام را اطلاع رسانی کند و سپس از بین برود.

به بیانی دیگر پردازه‌ها باید در مقابل مرگ ناگهانی مقاوم باشند.

از دیدگاه ویژگی‌های McCallاستفاده از این فاکتور باعث افزایش reliability و eficiency می‌شود زیرا افزایش سرعت startup پردازه‌ها معادل افزایش سرعت scaleup در فشار‌های کاری بالا و افزایش efficiency است. همچنین robust بودن در مقابل مرگ ناگهانی و خطا معادل reliability برنامه در ارائه‌ی خدمات است.

\subsubsection{\lr{Dev/prod parity}}
این فاکتور بیان می‌کند که در فرایند توسعه‌ی یک نرم‌افزار 
twelve-factor
، محیط‌های development
،
staging
و 
production
باید تا جای ممکن شبیه به هم نگهداری شوند.

این شباهت باید در نزدیکی زمانی و محتوایی کد، نزدیکی پرسنل توسعه دهنده و deploy کننده‌ی کد و همچنین نزدیکی ابزار‌های استفاده شده در فرایند development و production باشد.

با استفاده از فرایند 
\lr{continuous delivery}
سعی در کاهش فاصله‌ی زمانی کد و پرسنل توسعه و deploy می‌شود.

یک توسعه‌دهنده‌ی  
twelve-factor
سعی می‌کند
technology-stack
مورد استفاده در فرایند توسعه دقیقا همان 
technology-stack
مورد استفاده در production باشد.

از دیدگاه ویژگی‌های McCallاستفاده از این فاکتور باعث افزایش
testability
،
reliability
و
correctness
می‌شود.

شباهت کد توسعه و کد محصول نهایی و همچنین ابزار‌ها راه تست کردن و پیدا کردن ایرادات را هموار تر می‌کند.

تست راحت‌تر و عدم وجود ایرادات ناشی از تفاوت‌های 
technology-stack
باعث افزایش
correctness و همچنین reliability محصول خواهد بود.


\subsubsection{\lr{Logs}}
این فاکتور بیان می‌کند که یک برنامه‌ی 
twelve-factor
نباید خود را درگیر نوشتن لاگ‌ها در فایل‌های مربوط و مدیریت آنها بکند.

هر بخش از برنامه بایستی لاگ خود را در stdout بنویسد. توسعه دهنده در زمان توسعه‌ی این بخش لاگ را مشاهده کرده و بر اساس آن به ایراد زدایی و توسعه می‌پردازد.
 در production  لاگ هر ماژول توسط محیط اجرایی آن capture شده و در قالب مشخص و در محل تعیین شده برای بررسی و نگهداری طولانی مدت ذخیره می‌کند.
 
 این لاگ‌ها را می‌توان بعد‌ها توسط ابزار‌های مدیریت لاگ برای تحلیل‌های آماری و بررسی‌های سطح بالا مورد استفاده قرار داد.
 
 از دیدگاه ویژگی‌های McCallاستفاده از این فاکتور باعث افزایش
flexibility
خواهد شد زیرا توان مورد نیاز برای اصلاح یک ایراد در برنامه‌ی در حال اجرا با در نظر گرفتن و مشاهده‌ی لاگ‌های آن کاهش می‌یابد.

همچنین باعث افزایش testability و maintainability خواهد شد زیرا آزمون یک برنامه‌ی درحال اجرا و نگهداری از آن و برطرف کردن ایرادات آن با در اختیار داشتن خروجی‌ها و بازخورد‌های آن به تعاملات بسیار ساده تر خواهد بود.
 

\subsubsection{\lr{Admin processes}}
این فاکتور بیان می‌کند که در یک برنامه‌ی
twelve-factor
فعالیت‌ها و پردازه‌های کوتاه مدیریتی بایستی مانند پردازه‌های  طولانی و اصلی خدمت و در همان محیط و با همان پیکربندی اجرا شوند.

این پردازه‌ها و وظایف مانند دستورات کوتاه مدیریتی و نظارت و نگهداری و پشتیبان گیری غالبا به صورت فایل‌های script هستند.

فعالیت‌های مشابه dependency-isolation ای که برای کد اصلی خدمت انجام می‌شود باید برای این کد‌ها نیز انجام شود.

از دیدگاه ویژگی‌های McCallاستفاده از این فاکتور باعث افزایش
portability
و
maintainability
می‌شود زیرا ایزوله بودن این کد‌ها از وابستگی‌های خارجی باعث کاهش وابستگی برنامه به محیط اجرا می‌شود و همچنین یکسانی محیط اجرای این دستورات مدیریتی و دستورات طولانی خدمت باعث عدم نیاز به در نظر گرفتن تفاوت محیط‌ها در نگهداری  و سادگی فرایند آن خواهد بود.


\subsection{تضمین کیفی توسط متودولوژی؟}
این متودولوژی تعداد خوبی از مشکلات با نرخ رخداد بالا  در توسعه‌ی نرم‌افزار‌های SaaS  را آدرس‌دهی کرده  و برای حل آنها راه‌حل‌هایی را پیشنهاد می‌کند. استفاده از این متودولوژی قطعا در کیفیت نهایی نرم‌افزار تولید شده تاثیر خواهد داشت. اما می‌دانیم کیفیت یک معیار نسبی است و عوامل بسیار زیادی در آن موثرند. این متودولوژی به بسیاری از این عوامل می‌پردازد و سعی در بهبود آنها دارد ولی در نهایت تضمینی برای کیفیت بی نقص وجود ندارد.
